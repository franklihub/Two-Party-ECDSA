package twoecdsa

import (
	"crypto/elliptic"
	"math/big"
)

var secp256k1N, _ = new(big.Int).SetString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16)
var secp256k1halfN = new(big.Int).Div(secp256k1N, big.NewInt(2))

func hashToInt(hash []byte, c elliptic.Curve) *big.Int {
	orderBits := c.Params().N.BitLen()
	orderBytes := (orderBits + 7) / 8
	if len(hash) > orderBytes {
		hash = hash[:orderBytes]
	}

	ret := new(big.Int).SetBytes(hash)
	excess := len(hash)*8 - orderBits
	if excess > 0 {
		ret.Rsh(ret, uint(excess))
	}
	return ret
}

func SignMsg(msg []byte, prv *PrivateKey) (*big.Int, *big.Int, *big.Int, error) {
	N := prv.Curve.Params().N
	if N.Sign() == 0 {
		return nil, nil, nil, nil
	}
	var kInv, r, s, y *big.Int
	overflow := 0
	pubKeyRecoveryCode := byte(0)
	for i := uint32(0); ; i++ {
		for {
			k := Rand(prv.Curve)
			kInv = new(big.Int).ModInverse(k, N)

			r, y = prv.Curve.ScalarBaseMult(k.Bytes())
			if r.Cmp(N) != -1 {
				overflow = 1
			}
			r = r.Mod(r, N)
			if r.Sign() > 0 {
				break
			}
		}

		e := hashToInt(msg, prv.Curve)
		// s = k^-1(e + dr) mod N
		// Repeat from step 1 if s = 0
		// s = -s if s > N/2
		s = new(big.Int).Mul(prv.D, r)
		s.Add(s, e)
		s.Mul(s, kInv)
		s.Mod(s, N) // N != 0
		recoveryCode := byte(overflow<<1) | byte(y.Bit(0)&1)

		// Negating s corresponds to the random point that would have been
		// generated by -k (mod N), which necessarily has the opposite
		// oddness since N is prime, thus flip the pubkey recovery code
		// oddness bit accordingly.
		if s.Cmp(secp256k1halfN) > 0 {
			s = s.Neg(s)
			recoveryCode ^= 0x01
		}
		if s.Sign() > 0 {
			pubKeyRecoveryCode = recoveryCode
			break
		}
	}
	pubKeyRecoveryCode += 27
	// return encodeSignture(r.Bytes(), s.Bytes())
	return r, s, big.NewInt(0).SetBytes([]byte{pubKeyRecoveryCode}), nil
}
